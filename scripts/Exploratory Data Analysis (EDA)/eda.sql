use DataWarehouse;

--Checking out table contents
select top 10 * from gold.dim_customers;
select top 10 * from gold.dim_products;
select top 10 * from gold.fact_sales;

-- Divide datasets between dimensions and measures. For better understanding. 
-- Is my column a dimension or measure ? If data type is a numeric and makes sense to measure it is a measure.
-- Birthdate is dimension but age derived from that is a measure. 
-- Customer id is numeric but makes no sense to aggregate so it's not a measure. It's a dimension. 
-- Good practice to generate insights from datasets. 
-- Grouping data by dimensions. Measure is to answer how many and how much?

-- Step 1 : Database Exploration. First we check out the structure of database. 
select * from INFORMATION_SCHEMA.TABLES;
select * from INFORMATION_SCHEMA.COLUMNS;

-- Step 2 : Dimension Exploration. Identify unique value (or categories) in each dimension table. 
-- Recognizing how data might be grouped or segmented, which is usedful for later analysis. 
-- Distinct can be used. 

select top 10 * from gold.dim_customers;
select distinct country from gold.dim_customers; -- 6 different countries along with n/a
select distinct category from gold.dim_products; -- 4 types for products, along with null. 

select distinct category, subcategory, product_name -- granularity increases of dimensions related to each
from gold.dim_products order by 1, 2, 3; --other

-- Step 3 : Date Exploration
-- Identify earliest and latest date (boundaries). Understand scope of data and timespan.
-- Min/Max functions, and date functions can be used like Datediff to find timespan

-- Date of first and last order
select min(order_date) as first_order, 
	   max(order_date) as last_order,
	   datediff(year,min(order_date),max(order_date)) as order_range_years
from gold.fact_sales;

-- Finding youngest and oldest customer
select min(birthdate) as youngest_birthdate, 
       datediff(year, min(birthdate), getdate()) as youngest_age,
       max(birthdate) as oldest_birthdate,
	   datediff(year, max(birthdate), getdate()) as oldest_age
from gold.dim_customers; -- We don't have very young customers, youngest customer is 39 years old. 

-- Step 4 : Measure Exploration
-- Calculate the key metrics of the business (big numbers). Highest level of aggregation. Lowest level
-- of details. Using sum, avg, count etc. 

-- Total Sales
select sum(sales_amount) total_sales,
       sum(quantity) total_quantity,
	   avg(price) avg_price,
	   count(order_number) total_orders_actual,
	   count(distinct order_number) total_orders
from gold.fact_sales;

select * from gold.fact_sales where order_number = 'SO54496'; -- Customer orderd 3 thrings in the same 
-- order. That's why distinct and order_number counts are coming different. Total actual orders is, 
-- using after distinct. Use distinct when using count, it's tricky situation with count. 

-- Find total number of products
select count(product_key) as total_products from gold.dim_products;
select count(distinct product_key) as total_products from gold.dim_products; -- no duplicates. same count.

-- Find total number of customers;
select count(customer_key) as total_customers from gold.dim_customers;

-- Find total customers who have actually ordered something. 
select count(distinct customer_key) as total_actual_customers from gold.fact_sales; 
-- all customers did order. 

-- More structured report:
-- Generate a Report that shows all key metrics of the business
SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'Total Quantity', SUM(quantity) FROM gold.fact_sales
UNION ALL
SELECT 'Average Price', AVG(price) FROM gold.fact_sales
UNION ALL
SELECT 'Total Nr. Orders', COUNT(DISTINCT order_number) FROM gold.fact_sales
UNION ALL
SELECT 'Total Nr. Products', COUNT(product_name) FROM gold.dim_products
UNION ALL
SELECT 'Total Nr. Customers', COUNT(customer_key) FROM gold.dim_customers;

-- Step 5 : Magnitude Analysis
-- Compare measured values by categories. It helps understand the importance of different categories. 
-- Using where clause. We find out like total sales by country or average price by product subcategory.
-- Very basic analysis. 

-- Find total number of customers by countries. 

select 
	country,
	count(customer_key) as total_customers
from gold.dim_customers
group by country
order by total_customers desc

-- By gender
select   -- almost equal. 
	gender,
	count(customer_key) as total_customers
from gold.dim_customers
group by gender
order by total_customers desc

-- By Category
select   -- almost equal. 
	category,
	count(product_key) as total_products
from gold.dim_products
group by category
order by total_products desc

-- Average cost by category
select   -- almost equal. 
	category,
	avg(cost) as avg_cost
from gold.dim_products
group by category
order by avg_cost desc

-- What is total revenue generated by each category ?
-- Now here total revenue comes from fact and categor comes from another product dimension table.
-- So we'll have to use join. 
select p.category, sum(f.sales_amount) total_revenue
from gold.fact_sales f left join gold.dim_products p on p.product_key = f.product_key
group by p.category
order by total_revenue desc

-- What is total revenue generated by each customer ? Finding out highest paying customer.
select c.customer_key, c.first_name, c.last_name, sum(f.sales_amount) as total_sales
from gold.fact_sales f left join gold.dim_customers c on c.customer_key = f.customer_key
group by c.customer_key, c.first_name, c.last_name
order by total_sales desc

-- What is distribution of items sold accross countries ?
select c.country, sum(f.quantity) as total_quantity
from gold.fact_sales f left join gold.dim_customers c on c.customer_key = f.customer_key
group by c.country
order by total_quantity desc

-- If we have low number of values in dimensions, we call it low cardinality dimension. No. of rows
-- depends on cardinality of dimension. 

-- Step 6 : Ranking analysis
-- Orde the value of dimension based on measure. Identify top performers and bottom performers.
-- Countries ranked by total sales etc. 

-- What are 5 highest performing products by revenue ?
select  top 5 p.product_name, sum(f.sales_amount) as total_revenue
from gold.fact_sales f left join gold.dim_products p on p.product_key = f.product_key
group by p.product_name
order by total_revenue desc

-- What are 5 worst performing products ?
select  top 5 p.product_name, sum(f.sales_amount) as total_revenue
from gold.fact_sales f left join gold.dim_products p on p.product_key = f.product_key
group by p.product_name
order by total_revenue

-- Best subcategories in our business ?
select  top 5 p.subcategory, sum(f.sales_amount) as total_revenue
from gold.fact_sales f left join gold.dim_products p on p.product_key = f.product_key
group by p.subcategory
order by total_revenue desc

-- For more flexible and complex queries with extra details, I'm going to use window functions.
select * from (
select p.product_name, sum(f.sales_amount) as total_revenue,
row_number() over (order by sum(f.sales_amount) desc) as rank_products
from gold.fact_sales f left join gold.dim_products p on p.product_key = f.product_key
group by p.product_name)t
where rank_products <= 5;

-- Find the top 10 customers who have generated the highest revenue
SELECT TOP 10
    c.customer_key,
    c.first_name,
    c.last_name,
    SUM(f.sales_amount) AS total_revenue
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_revenue DESC;


-- The 3 customers with the fewest orders placed
SELECT TOP 3
    c.customer_key,
    c.first_name,
    c.last_name,
    COUNT(DISTINCT order_number) AS total_orders
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_orders;
